"""Template engine for generating pytest security test files."""

from whitehats.models.target import APITarget, Target, URLTarget


class TemplateEngine:
    """Renders pytest test file templates for security testing."""

    def render_api_test(self, target: Target) -> str:
        """Render a pytest test file for an API target."""
        if not isinstance(target, APITarget):
            raise TypeError("Expected APITarget")

        method = target.method.value
        url = target.url
        headers = repr(target.get_request_headers())
        params = repr(target.params)
        body = repr(target.body)

        return f'''"""
Auto-generated security test cases for: {url}
Method: {method}
Generated by WhiteHats Security Testing Framework
"""
import pytest
import requests


TARGET_URL = "{url}"
METHOD = "{method}"
HEADERS = {headers}
PARAMS = {params}
BODY = {body}


class TestSQLInjection:
    """SQL Injection tests for {url}"""

    SQL_PAYLOADS = [
        "\\' OR \\'1\\'=\\'1",
        "\\" OR \\"1\\"=\\"1",
        "\\' OR 1=1 --",
        "\\' UNION SELECT NULL --",
        "1; DROP TABLE users --",
        "\\' AND SLEEP(5) --",
    ]

    @pytest.mark.parametrize("payload", SQL_PAYLOADS)
    def test_sql_injection_params(self, payload, security_session):
        """Test SQL injection via query parameters."""
        for param_name in PARAMS:
            injected = dict(PARAMS)
            injected[param_name] = payload
            resp = security_session.request(
                METHOD, TARGET_URL, headers=HEADERS, params=injected, timeout=10
            )
            assert resp.status_code != 500, (
                f"Possible SQL injection in param '{{param_name}}' with payload: {{payload}}"
            )

    @pytest.mark.parametrize("payload", SQL_PAYLOADS)
    def test_sql_injection_body(self, payload, security_session):
        """Test SQL injection via request body fields."""
        if not BODY or not isinstance(BODY, dict):
            pytest.skip("No body fields to test")
        for field_name, field_value in BODY.items():
            if not isinstance(field_value, str):
                continue
            injected = dict(BODY)
            injected[field_name] = payload
            resp = security_session.request(
                METHOD, TARGET_URL, headers=HEADERS, params=PARAMS,
                json=injected, timeout=10
            )
            assert resp.status_code != 500, (
                f"Possible SQL injection in body field '{{field_name}}' with payload: {{payload}}"
            )


class TestXSS:
    """Cross-Site Scripting tests for {url}"""

    XSS_PAYLOADS = [
        "<script>alert(\\'XSS\\')</script>",
        "<img src=x onerror=alert(\\'XSS\\')>",
        "<svg onload=alert(\\'XSS\\')>",
        "\\"><script>alert(\\'XSS\\')</script>",
    ]

    @pytest.mark.parametrize("payload", XSS_PAYLOADS)
    def test_xss_reflection_params(self, payload, security_session):
        """Test for reflected XSS in query parameters."""
        for param_name in PARAMS:
            injected = dict(PARAMS)
            injected[param_name] = payload
            resp = security_session.request(
                METHOD, TARGET_URL, headers=HEADERS, params=injected, timeout=10
            )
            assert payload not in resp.text, (
                f"XSS payload reflected in response for param '{{param_name}}'"
            )


class TestSecurityHeaders:
    """Security headers tests for {url}"""

    REQUIRED_HEADERS = [
        "Strict-Transport-Security",
        "X-Content-Type-Options",
        "X-Frame-Options",
        "Content-Security-Policy",
    ]

    def test_security_headers_present(self, security_session):
        """Verify required security headers are present."""
        resp = security_session.request(METHOD, TARGET_URL, headers=HEADERS, params=PARAMS, timeout=10)
        missing = [h for h in self.REQUIRED_HEADERS if h not in resp.headers]
        assert not missing, f"Missing security headers: {{missing}}"

    def test_no_server_info_leak(self, security_session):
        """Verify server does not leak version info."""
        resp = security_session.request(METHOD, TARGET_URL, headers=HEADERS, params=PARAMS, timeout=10)
        for header in ["Server", "X-Powered-By", "X-AspNet-Version"]:
            if header in resp.headers:
                pytest.fail(f"Information disclosure via header: {{header}}: {{resp.headers[header]}}")


class TestCORS:
    """CORS misconfiguration tests for {url}"""

    def test_cors_wildcard(self, security_session):
        """Test for wildcard CORS origin."""
        h = dict(HEADERS)
        h["Origin"] = "https://evil.example.com"
        resp = security_session.request("GET", TARGET_URL, headers=h, timeout=10)
        acao = resp.headers.get("Access-Control-Allow-Origin", "")
        assert acao != "*", "CORS allows wildcard origin"

    def test_cors_origin_reflection(self, security_session):
        """Test if server reflects arbitrary origins."""
        evil = "https://attacker.evil.com"
        h = dict(HEADERS)
        h["Origin"] = evil
        resp = security_session.request("GET", TARGET_URL, headers=h, timeout=10)
        acao = resp.headers.get("Access-Control-Allow-Origin", "")
        assert acao != evil, "CORS reflects arbitrary origin"


class TestCSRF:
    """CSRF protection tests for {url}"""

    def test_csrf_protection(self, security_session):
        """Test that state-changing endpoints require CSRF protection."""
        if METHOD in ("GET", "HEAD", "OPTIONS"):
            pytest.skip("Not a state-changing method")
        resp = security_session.request(
            METHOD, TARGET_URL, headers=HEADERS, params=PARAMS,
            json=BODY, timeout=10
        )
        # A successful response without CSRF token may indicate missing protection
        if resp.status_code < 400:
            pytest.fail(
                f"State-changing endpoint accepted request without CSRF token (status {{resp.status_code}})"
            )
'''

    def render_url_test(self, target: Target) -> str:
        """Render a pytest test file for a URL target."""
        if not isinstance(target, URLTarget):
            raise TypeError("Expected URLTarget")

        url = target.url
        headers = repr(dict(target.headers))

        return f'''"""
Auto-generated security test cases for: {url}
Type: URL
Generated by WhiteHats Security Testing Framework
"""
import pytest
import requests
from urllib.parse import urlparse, parse_qs, urlencode, urlunparse


TARGET_URL = "{url}"
HEADERS = {headers}


class TestSecurityHeaders:
    """Security headers tests for {url}"""

    REQUIRED_HEADERS = [
        "Strict-Transport-Security",
        "X-Content-Type-Options",
        "X-Frame-Options",
        "Content-Security-Policy",
    ]

    def test_security_headers_present(self, security_session):
        resp = security_session.get(TARGET_URL, headers=HEADERS, timeout=10)
        missing = [h for h in self.REQUIRED_HEADERS if h not in resp.headers]
        assert not missing, f"Missing security headers: {{missing}}"

    def test_no_server_info_leak(self, security_session):
        resp = security_session.get(TARGET_URL, headers=HEADERS, timeout=10)
        for header in ["Server", "X-Powered-By", "X-AspNet-Version"]:
            if header in resp.headers:
                pytest.fail(f"Information disclosure: {{header}}: {{resp.headers[header]}}")


class TestCORS:
    """CORS tests for {url}"""

    def test_cors_wildcard(self, security_session):
        h = dict(HEADERS)
        h["Origin"] = "https://evil.example.com"
        resp = security_session.get(TARGET_URL, headers=h, timeout=10)
        acao = resp.headers.get("Access-Control-Allow-Origin", "")
        assert acao != "*", "CORS allows wildcard origin"

    def test_cors_origin_reflection(self, security_session):
        evil = "https://attacker.evil.com"
        h = dict(HEADERS)
        h["Origin"] = evil
        resp = security_session.get(TARGET_URL, headers=h, timeout=10)
        acao = resp.headers.get("Access-Control-Allow-Origin", "")
        assert acao != evil, "CORS reflects arbitrary origin"


class TestSQLInjectionURL:
    """SQL Injection tests for URL parameters in {url}"""

    SQL_PAYLOADS = [
        "\\' OR \\'1\\'=\\'1",
        "\\" OR \\"1\\"=\\"1",
        "\\' OR 1=1 --",
        "\\' UNION SELECT NULL --",
    ]

    @pytest.mark.parametrize("payload", SQL_PAYLOADS)
    def test_sql_injection_url_params(self, payload, security_session):
        parsed = urlparse(TARGET_URL)
        params = parse_qs(parsed.query, keep_blank_values=True)
        if not params:
            pytest.skip("No URL parameters to test")
        for param_name in params:
            injected = dict(params)
            injected[param_name] = [payload]
            new_query = urlencode(injected, doseq=True)
            test_url = urlunparse(parsed._replace(query=new_query))
            resp = security_session.get(test_url, headers=HEADERS, timeout=10)
            assert resp.status_code != 500, (
                f"Possible SQL injection in URL param '{{param_name}}'"
            )


class TestXSSURL:
    """XSS tests for URL parameters in {url}"""

    XSS_PAYLOADS = [
        "<script>alert(\\'XSS\\')</script>",
        "<img src=x onerror=alert(\\'XSS\\')>",
    ]

    @pytest.mark.parametrize("payload", XSS_PAYLOADS)
    def test_xss_url_params(self, payload, security_session):
        parsed = urlparse(TARGET_URL)
        params = parse_qs(parsed.query, keep_blank_values=True)
        if not params:
            pytest.skip("No URL parameters to test")
        for param_name in params:
            injected = dict(params)
            injected[param_name] = [payload]
            new_query = urlencode(injected, doseq=True)
            test_url = urlunparse(parsed._replace(query=new_query))
            resp = security_session.get(test_url, headers=HEADERS, timeout=10)
            assert payload not in resp.text, (
                f"XSS payload reflected for URL param '{{param_name}}'"
            )


class TestInfoDisclosure:
    """Information disclosure tests for {url}"""

    def test_error_page_info_leak(self, security_session):
        from urllib.parse import urljoin
        error_url = urljoin(TARGET_URL, "/whitehat_test_nonexistent_404")
        resp = security_session.get(error_url, headers=HEADERS, timeout=10)
        dangerous_patterns = ["Traceback", "Exception in thread", "Fatal error"]
        for pattern in dangerous_patterns:
            assert pattern not in resp.text, (
                f"Error page reveals sensitive info: {{pattern}}"
            )
'''

    def render_conftest(self, targets: list) -> str:
        """Render conftest.py with shared fixtures."""
        return '''"""
Shared fixtures for auto-generated security tests.
Generated by WhiteHats Security Testing Framework
"""
import pytest
import requests


@pytest.fixture
def security_session():
    """Create a requests session for security testing."""
    session = requests.Session()
    session.headers.update({
        "User-Agent": "WhiteHats-SecurityScanner/1.0",
    })
    yield session
    session.close()
'''
