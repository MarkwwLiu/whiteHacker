"""Unit tests for standalone exporter."""

import os
import tempfile

import pytest

from whitehats.generator.standalone_exporter import StandaloneExporter


# A sample generated test file (mimics what TestGenerator produces for an API target)
SAMPLE_API_TEST = '''\
"""
Auto-generated security test cases for: https://example.com/api/users
Method: GET
Generated by WhiteHats Security Testing Framework
"""
import pytest
import requests


TARGET_URL = "https://example.com/api/users"
METHOD = "GET"
HEADERS = {'Content-Type': 'application/json'}
PARAMS = {'id': '1'}
BODY = None


class TestSQLInjection:
    """SQL Injection tests for https://example.com/api/users"""

    SQL_PAYLOADS = [
        "' OR '1'='1",
        "' OR 1=1 --",
    ]

    @pytest.mark.parametrize("payload", SQL_PAYLOADS)
    def test_sql_injection_params(self, payload, security_session):
        for param_name in PARAMS:
            injected = dict(PARAMS)
            injected[param_name] = payload
            resp = security_session.request(
                METHOD, TARGET_URL, headers=HEADERS, params=injected, timeout=10
            )
            assert resp.status_code != 500


class TestSecurityHeaders:
    REQUIRED_HEADERS = [
        "Strict-Transport-Security",
        "X-Content-Type-Options",
    ]

    def test_security_headers_present(self, security_session):
        resp = security_session.request(METHOD, TARGET_URL, headers=HEADERS, params=PARAMS, timeout=10)
        missing = [h for h in self.REQUIRED_HEADERS if h not in resp.headers]
        assert not missing
'''

SAMPLE_URL_TEST = '''\
"""
Auto-generated security test cases for: https://example.com
Type: URL
Generated by WhiteHats Security Testing Framework
"""
import pytest
import requests
from urllib.parse import urlparse, parse_qs, urlencode, urlunparse


TARGET_URL = "https://example.com"
HEADERS = {}


class TestSecurityHeaders:
    REQUIRED_HEADERS = ["Strict-Transport-Security"]

    def test_security_headers_present(self, security_session):
        resp = security_session.get(TARGET_URL, headers=HEADERS, timeout=10)
        missing = [h for h in self.REQUIRED_HEADERS if h not in resp.headers]
        assert not missing
'''


class TestStandaloneExporter:
    def test_export_api_test(self):
        with tempfile.TemporaryDirectory() as tmpdir:
            source = os.path.join(tmpdir, "test_security_example.py")
            with open(source, "w") as f:
                f.write(SAMPLE_API_TEST)

            exporter = StandaloneExporter()
            output = exporter.export(source)

            assert os.path.exists(output)
            assert "standalone_" in os.path.basename(output)

            content = open(output).read()
            # Should have inline fixture
            assert "def security_session" in content
            # Should have test classes preserved
            assert "class TestSQLInjection" in content
            assert "class TestSecurityHeaders" in content
            # Should have target constants
            assert 'TARGET_URL = "https://example.com/api/users"' in content
            # Should NOT have duplicate imports
            lines = content.splitlines()
            import_pytest_count = sum(1 for l in lines if l.strip() == "import pytest")
            assert import_pytest_count == 1

    def test_export_url_test(self):
        with tempfile.TemporaryDirectory() as tmpdir:
            source = os.path.join(tmpdir, "test_security_examplecom.py")
            with open(source, "w") as f:
                f.write(SAMPLE_URL_TEST)

            exporter = StandaloneExporter()
            output = exporter.export(source)

            content = open(output).read()
            assert "def security_session" in content
            assert "class TestSecurityHeaders" in content
            assert "TARGET_URL" in content

    def test_export_custom_output_path(self):
        with tempfile.TemporaryDirectory() as tmpdir:
            source = os.path.join(tmpdir, "test_security_example.py")
            with open(source, "w") as f:
                f.write(SAMPLE_API_TEST)

            custom_out = os.path.join(tmpdir, "my_script.py")
            exporter = StandaloneExporter()
            output = exporter.export(source, output_path=custom_out)

            assert output == custom_out
            assert os.path.exists(custom_out)

    def test_export_nonexistent_source(self):
        exporter = StandaloneExporter()
        with pytest.raises(FileNotFoundError):
            exporter.export("/nonexistent/test_file.py")

    def test_list_exportable(self):
        with tempfile.TemporaryDirectory() as tmpdir:
            # Create some test files
            for name in [
                "test_security_api1.py",
                "test_security_api2.py",
                "conftest.py",
                "other_file.py",
            ]:
                with open(os.path.join(tmpdir, name), "w") as f:
                    f.write("# placeholder")

            exporter = StandaloneExporter()
            files = exporter.list_exportable(tmpdir)
            assert len(files) == 2
            assert all("test_security_" in f for f in files)

    def test_list_exportable_empty_dir(self):
        with tempfile.TemporaryDirectory() as tmpdir:
            exporter = StandaloneExporter()
            files = exporter.list_exportable(tmpdir)
            assert files == []

    def test_list_exportable_nonexistent_dir(self):
        exporter = StandaloneExporter()
        files = exporter.list_exportable("/nonexistent/path")
        assert files == []

    def test_exported_script_is_valid_python(self):
        """Verify the exported script can be compiled (no syntax errors)."""
        with tempfile.TemporaryDirectory() as tmpdir:
            source = os.path.join(tmpdir, "test_security_example.py")
            with open(source, "w") as f:
                f.write(SAMPLE_API_TEST)

            exporter = StandaloneExporter()
            output = exporter.export(source)

            content = open(output).read()
            # This will raise SyntaxError if the output is invalid Python
            compile(content, output, "exec")
